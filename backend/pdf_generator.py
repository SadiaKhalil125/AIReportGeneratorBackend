from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib import colors
from datetime import datetime
import textwrap

class PDFGenerator:
    def __init__(self):
        self.styles = getSampleStyleSheet()
        self.custom_styles = self._create_custom_styles()
    
    def _create_custom_styles(self):
        styles = {}
        
        # Title style
        styles['title'] = ParagraphStyle(
            'CustomTitle',
            parent=self.styles['Heading1'],
            fontSize=24,
            spaceAfter=30,
            alignment=1,  # Center alignment
            textColor=colors.darkblue
        )
        
        # Subtitle style
        styles['subtitle'] = ParagraphStyle(
            'CustomSubtitle',
            parent=self.styles['Heading2'],
            fontSize=16,
            spaceAfter=20,
            textColor=colors.darkblue
        )
        
        # Normal text style
        styles['normal'] = ParagraphStyle(
            'CustomNormal',
            parent=self.styles['Normal'],
            fontSize=12,
            spaceAfter=12,
            leading=18
        )
        
        return styles
    
    def create_report(self, topic: str, content: str, author: str, file_path: str):
        doc = SimpleDocTemplate(
            file_path,
            pagesize=A4,
            rightMargin=72,
            leftMargin=72,
            topMargin=72,
            bottomMargin=18
        )
        
        # Build the PDF content
        story = []
        
        # Add title
        title = Paragraph(f"Research Report: {topic}", self.custom_styles['title'])
        story.append(title)
        story.append(Spacer(1, 12))
        
        # Add metadata table
        metadata_data = [
            ['Author:', author],
            ['Topic:', topic],
            ['Generated:', datetime.now().strftime("%Y-%m-%d %H:%M:%S")],
            ['Generated by:', 'GenAI Report Generator']
        ]
        
        metadata_table = Table(metadata_data, colWidths=[1.5*inch, 4*inch])
        metadata_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.lightgrey),
            ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTNAME', (1, 0), (1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        
        story.append(metadata_table)
        story.append(Spacer(1, 30))
        
        # Add content sections
        sections = self._parse_content_into_sections(content)
        
        for section_title, section_content in sections:
            if section_title:
                story.append(Paragraph(section_title, self.custom_styles['subtitle']))
                story.append(Spacer(1, 12))
            
            # Split content into paragraphs
            paragraphs = section_content.split('\n\n')
            for para in paragraphs:
                if para.strip():
                    story.append(Paragraph(para.strip(), self.custom_styles['normal']))
                    story.append(Spacer(1, 6))
        
        # Build the PDF
        doc.build(story)
    
    def _parse_content_into_sections(self, content: str):
        """Parse AI-generated content into sections"""
        sections = []
        
        # Simple parsing - look for headers (lines that end with :)
        lines = content.split('\n')
        current_section_title = None
        current_section_content = []
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
                
            # Check if this looks like a header
            if (line.endswith(':') and len(line) < 100 and 
                not line.startswith('â€¢') and not line.startswith('-')):
                # Save previous section if exists
                if current_section_title or current_section_content:
                    sections.append((
                        current_section_title, 
                        '\n'.join(current_section_content)
                    ))
                
                # Start new section
                current_section_title = line
                current_section_content = []
            else:
                current_section_content.append(line)
        
        # Add the last section
        if current_section_title or current_section_content:
            sections.append((
                current_section_title, 
                '\n'.join(current_section_content)
            ))
        
        # If no sections were found, treat entire content as one section
        if not sections:
            sections = [(None, content)]
        
        return sections 